syntax = "proto3";
package packets;

import "serialization/persistence.proto";

option java_multiple_files = false;
option java_package = "no.elg.infiniteBootleg.protobuf";
option java_outer_classname = "Packets";

message Packet {
  // There are three types of packets
  // 1. DX (duplex) Sent both to server and to client
  // 2. SB (Server Bound) Only sent to server
  // 3. CB (Client Bound) Only sent to client
  enum Type {
    DX_HEARTBEAT = 0;
    SB_LOGIN = 1;
    DX_MOVE_ENTITY = 2;
    DX_BLOCK_UPDATE = 3;
    CB_START_GAME = 4;
    CB_UPDATE_CHUNK = 5;
    CB_LOGIN_STATUS = 6;
    SB_CLIENT_WORLD_LOADED = 7; //no message associated
    SB_CHUNK_REQUEST = 8;
    DX_DISCONNECT = 9;
    DX_SECRET_EXCHANGE = 10;
    CB_SPAWN_ENTITY = 11;
    CB_DESPAWN_ENTITY = 12;
    SB_ENTITY_REQUEST = 13;
    CB_INITIAL_CHUNKS_SENT = 14; //no message associated
    DX_WORLD_SETTINGS = 15;
  }

  enum Direction {
    SERVER = 0;
    CLIENT = 1;
  }

  Type type = 1;
  Direction direction = 2;
  optional string secret = 3; //Only optional before sharing the secret

  //very frequent packets
  optional Heartbeat heartbeat = 8; //dual
  optional MoveEntity moveEntity = 9; //dual
  optional UpdateChunk updateChunk = 10; //client bound
  optional SpawnEntity spawnEntity = 11;
  optional DespawnEntity despawnEntity = 12;
  optional UpdateBlock updateBlock = 13; //dual

  //more rare packets
  optional Login login = 17; //server bound
  optional StartGame startGame = 18; //client bound
  optional ServerLoginStatus serverLoginStatus = 20; //client bound
  optional Disconnect disconnect = 21;
  optional SecretExchange secretExchange = 22;
  optional ChunkRequest chunkRequest = 23; //server bound
  optional EntityRequest entityRequest = 24;
  optional WorldSettings worldSettings = 25;
}

////////////////
// DUAL BOUND //
////////////////

// Server send this every tick (??), client must respond with another heartbeat packet with the name keepAliveId
message Heartbeat {
  string keepAliveId = 1;
}

message UpdateBlock {
  .persistence.Vector2i pos = 1;
  optional .persistence.Block block = 2;
}

message MoveEntity {
  //Id of entity to move
  string uuid = 1;
  .persistence.Vector2f velocity = 2;
  .persistence.Vector2f position = 3;
  float lookAngleDeg = 4;
}

message Disconnect {
  string reason = 1;
}

message SecretExchange{
  string entityUUID = 1;
  string secret = 2;
}

//if not present, do not update setting
message WorldSettings {
  optional float time = 1;
  optional float timeScale = 2;
  optional .persistence.Vector2i spawn = 3;
}

//////////////////
// CLIENT BOUND //
//////////////////

message StartGame {
  //The entity the client is controlling
  .persistence.Entity controlling = 1;

  // the world info of the server
  .persistence.World world = 2;
}

// Update all blocks in a chunk
message UpdateChunk {
  .persistence.Chunk chunk = 1;
}

message ServerLoginStatus {
  enum ServerStatus {
    //Player login ok, chunks will be sent
    PROCEED_LOGIN = 0;
    //Someone with the given uuid or name is already logged in
    ALREADY_LOGGED_IN = 1;
    //The server is full
    FULL_SERVER = 2;

    //Fully logged in, spawn player
    LOGIN_SUCCESS = 3;
  }
  ServerStatus status = 1;
}

message SpawnEntity {
  .persistence.Entity entity = 1;
  string uuid = 2;
}

message DespawnEntity {
  enum DespawnReason{
    UNKNOWN_REASON = 0; //
    KILLED = 1;
    PLAYER_QUIT = 2; // players only
    CHUNK_UNLOADED = 3;
    UNKNOWN_ENTITY = 4; // Unknown entity by the server
    PLAYER_KICKED = 5; // players only
  }
  string uuid = 1;
  DespawnReason despawnReason = 2;
}

//////////////////
// SERVER BOUND //
//////////////////

message Login {
  string uuid = 1;
  string username = 2;
  //client version
  string version = 3;
}

message ChunkRequest {
  .persistence.Vector2i chunkLocation = 1;
}

message EntityRequest {
  string uuid = 1;
}
